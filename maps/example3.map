9
7
3 1 6 2 1 4 3
2 5 1 1 1 1 0
3 1 3 7 1 1 3
1 1 8 2 1 1 1
2 3 1 1 4 3 1
1 1 1 6 1 1 2
2 1 3 1 1 1 1
1 2 3 1 5 2 4
1 1 1 1 1 3 1




DANS MAP.h

void displayPathVisual(t_map map, int (*display_path_visual)[map.y_max], t_localisation *list_pos, int length_list);

DANS MAP.C
void displayPathVisual(t_map map,int (*display_path_visual)[map.y_max], t_localisation *list_pos, int length_list) {
    for (int i = 0; i < length_list; i++) {
        printf("list_pos[%d]: (%d, %d)\n", i, list_pos[i].pos.x, list_pos[i].pos.y);
    }
    for (int i = 0; i < length_list; i++) {  //the length of the list
        if (list_pos[i].ori == NORTH || list_pos[i].ori == SOUTH) {
            display_path_visual[list_pos[i].pos.y][list_pos[i].pos.x] = 1;
        } else {
            display_path_visual[list_pos[i].pos.y][list_pos[i].pos.x] = 2;
        }
        if (i != 0) {
            int diff_pos_y = list_pos[i].pos.y - list_pos[i - 1].pos.y;
            int diff_pos_x = list_pos[i].pos.x - list_pos[i - 1].pos.x;

            // Fill gaps in the path
            if (abs(diff_pos_y) > 1) {
                int step = diff_pos_y / abs(diff_pos_y);
                for (int k = 1; k < abs(diff_pos_y); k++) {
                    display_path_visual[list_pos[i - 1].pos.y + k * step][list_pos[i].pos.x] = 1;
                }
            }
            if (abs(diff_pos_x) > 1) {
                int step = diff_pos_x / abs(diff_pos_x);
                for (int k = 1; k < abs(diff_pos_x); k++) {
                    display_path_visual[list_pos[i].pos.y][list_pos[i - 1].pos.x + k * step] = 2;
                }
            }
        }

    }
    display_path_visual[list_pos[length_list - 1].pos.y][list_pos[length_list - 1].pos.x] = 3;
    for (int i = 0; i < map.y_max; i++) {
        for (int j = 0; j < map.x_max; j++) {
            switch (display_path_visual[i][j]) {
                case 1:
                    printf(" | ");
                    break;
                case 2:
                    printf("===");
                    break;
                case 3:
                    printf(" %c ", print_rover(list_pos[length_list-1].ori));
                    break;
                default:
                    printf("...");
                    break;
                }
            }
        printf("\n");
        }
    }


DANS MAIN PARES BEST_COST = 1

int size_list_loc = 5;
t_localisation *list_loc = (t_localisation *)malloc(size_list_loc * sizeof(t_localisation));
list_loc[0] = rover;


 En dessous de rover.ori = best_path[i]->loc.ori;
list_loc[i].pos = rover.pos;
list_loc[i].ori = rover.ori;

En dessous de if (map.soils[best_path[i]->loc.pos.y][best_path[i]->loc.pos.x] == BASE_STATION) {
                              base_reached = 1;


                             if (i != best_path_length){
                                                size_list_loc = size_list_loc-i;
                                                realloc(list_loc, size_list_loc * sizeof(int));
                                            }

APRES LES 5 \n
displayPathVisual(map, display_path_visual, list_loc, size_list_loc);